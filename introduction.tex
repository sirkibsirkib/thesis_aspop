\chapter{Introduction}

Many tasks in fields related to bioinformatics make use of data from \textsc{dna} or \textsc{rna} sequences, performing computations with strings of symbols representing genomes of nucleotides. The precise order and position of nucleotides in a genome cannot practically be read in a single pass using todayâ€™s technology. A popular alternative reads snippets of the genome at a time, bringing rise to several short \textit{reads} from the \gls{source genome}, but from unknown positions in the original sequence. Acquisition of the entire genome is then a matter of re-assembling several such sets of reads into longer sequences (called `contigs') in an iterative process. Eventually, much or all of the genome can be reconstructed using this \textit{sequence assembly}.
 
Part of this assembly process necessitates knowing which of the reads have significant overlap with one another, particularly the overlap of one read's suffix with another read's prefix. \textit{Assembly graphs}\footnote{These are also sometimes called `overlap graphs'.} interpret overlapping reads as adjacent nodes, forming chains of reads that illuminate likely sequences of nucleotides that made up the source genome. Assembly of these reads is known as the \textit{Overlap Layout Consensus problem}. Unfortunately, the reading process is error-prone at the physical level, necessitating the consideration of \textit{approximate} overlaps, whose reads are within a reasonable \gls{error distance} of each other. The search for these overlaps is known as the \textit{Approximate Suffix-Prefix Overlap Problem}, henceforth shortened to the `\aspop{}'.
 
In addition to many popular heuristic-based search algorithms for solutions to the \aspop{}, exact algorithms have been available for some time. However, their usefulness was inhibited by their high computational cost. \Glspl{filter algorithm} offer a way of speeding up these exact algorithms, bringing them into the realm of feasibility. \Glspl{suffix filter} in particular can solve for exact solutions faster than the naive approach. Their use presents a number of algorithmic design decisions that determine their time and space complexities; A good filter algorithm reduces solve time by orders of magnitude. Various related works by \kark{} et al, \vali{} et al and Kucherov et al have iteratively sought to optimize these suffix filters, resulting in a number of algorithms seeking to solve the same problem in slightly different ways.

Our goal was to build a new \aspop{} solver with the best output quality and run speed possible, demonstrate its abilities, and explore its limitations. To that end, we aimed to compare the existing works of \kark{}\footnote{The works of these three groups are regularly mentioned throughout this thesis. To avoid clutter, we will abbreviate `\kark{} et al' to the plurality `\kark{}', and likewise for \vali{} and Kucherov.}, \vali{}, and Kucherov to understand the nature of the problem. The final implementation would use the best-performing algorithm, with any novel adjustments necessary to optimize its speed. Additionally, the solver is to expose several controls to the user, allowing them to optionally find additional kinds of \glspl{solution} when the system's various \textit{extensions} are enabled.

Ultimately, we demonstrate the output quality and speed of our systems with respect to some established heuristic-based solvers \textsc{blast}~\cite{blast} and Minimap~\cite{minimap}, in order to demonstrate the utility of such suffix-filter based solvers for sequence assembly.
