
\section{Algorithm Extensions}
\label{extensions}

The work in the \vali{} and Kucherov papers focuses primarily on the most fundamental aspects of solving the \aspop{}. Extensions exist that facilitate discovery of additional \glspl{solution}, namely \glspl{inclusion}, those brought about by consideration of \glspl{reversal}, as well as support for \gls{edit distance} as an \gls{error distance} measure. As none of these extensions change the fundamentals of the algorithms, \vali{} and Kucherov don't delve too deeply into how they should be implemented. However, the use of these extensions factors greatly into runtime, as well as requiring a significant amount of original work to implement them into the \aspop{} solver effectively.



\subsection{Edit Distance}
\label{editdistance}

\Gls{insertion} or \gls{deletion} \glspl{error} are often given the general name `\glspl{indel}'. For realistic applications in genome assembly, it is sometimes advantageous to consider \gls{edit distance}  instead of \gls{Hamming distance}), as it is defined for strings of different lengths and is more representative of the ways single-symbol errors can by physically introduced when reading genomic information. The support for these indel operations necessitates changes in both steps of the \gls{suffix filter} algorithm:

\begin{enumerate}
\item Changes to the \gls{search step}

The search procedure needs to allow branches that represent indel errors in the \gls{derivation} of match strings from the \gls{query} string. These added error operations manifest as a new set of recursive calls at each node in the search tree.

\item Changes to the \gls{verification step}

The computation to measure the error intrinsic to a \gls{candidate}â€™s overlap needs to be in terms of edit distance.
\end{enumerate}

Indels differentiate the lengths of the overlapping components $A$ and $B$ between the \gls{pattern} string and its \textit{match string} in the \gls{text} respectively; \Glspl{insertion} increase the length of $B$ without changing the length of $A$; \Glspl{deletion} increase the length $A$ without changing the length of $B$. These added operations necessitate that both two lengths be decoupled and stored \textit{separately} in each symbol-step of the \gls{text index}'s recursive \gls{query} search. Concepts such as \gls{string partition} size and permitted errors are defined in terms overlap length; At first glance this seems to present a circular definition, with each indel error influencing how many indel errors are permitted (by changing overlap length). Fortunately, this problem can be resolved due to the \gls{error rate} limit parameter (\bfit{e}) being strictly lower than 1, where a lengthening \gls{derived string} will always run out of errors faster than it accumulates length from errors (in the most extreme case, all errors are insertions, increasing length); This assures a hard cap for the length of derived strings.
 
In addition to complicating the algorithm conceptually and requiring further checks, the permission of indels greatly increases the branching factor of the query search, as simply more derivation branches are possible at each node in the search tree with the added operations. Thankfully, some branching \textit{rules} can be incorporated to curtail this branching factor without affecting the correctness of the algorithm. For instance, a rule could prohibit a deletion at index $N+1$ if there was an insertion at index $N$ in the same search path. Any \glspl{candidate} generated by nodes within the subtree with its root at index $N+1$ would also have been found by the subtree resulting from a \gls{substitution} at index $N$; No candidates will be overlooked by enforcing this branching rule. Many other such rules can be introduced to avoid redundant work in each search in this manner.


\subsection{Reversals}
\label{reversals}

The consideration of \glspl{reversal} comes from an application perspective. For genome assembly, \gls{read} strings in the input set $S$ are collected by reading nucleotides that are encountered when passing over a strand of \textsc{dna} or \textsc{rna} (some genomic material). In some instances, this strand is tightly bound to another companion strand, with connections at each nucleotide. Such nucleotide \textit{base pairs} always couple symmetrically and predictably, with `A' pairing with `T' and `C' pairing with `G'. Although this other strand is not read, its nucleotide sequence can be \textit{deduced} by leveraging the knowledge of its companion (which \textit{is} read). In this event, the algorithm can internally consider two strings per input string in $S$ (one given string, and one companion string) to find new overlaps involving these reversals.
 
The use of reversals has a similar impact on runtime as the use of an $S$ set twice the size. Additionally, some care must be taken as with two \textit{versions} of each read in the \gls{text}, the same solution could be found twice. Some minor bookkeeping is needed to avoid or resolve this duplication; The approach used in our implemented \aspop{} solver is detailed in Section \ref{impl:dedup}.






\subsection{Inclusions}
\label{inclusions}

\Glspl{inclusion} are a class of overlap \gls{solution} between two strings different to the suffix-prefix overlaps considered thus far. Some string $A$ is \textit{included} within some string $B$ if $A$ matches a substring of $B$. As before, this concept can be extended with the use of \glspl{error} to define a \gls{K-approximate} inclusion.
 
Knowing that two \glspl{read} came from the same genomic sequence facilitates some confidence in the correctness of the read symbols, provide redundant symbols for error correction, and helps the estimation of read `quality' (probability of misread symbols). In addition to suffix-prefix overlaps, inclusions can find such overlapping reads.
 
Extending the \aspop{} \gls{suffix filter} algorithm to also find inclusion \glspl{solution} can be done in a number of ways. One such way involves a minor change to the \gls{text index}'s search procedure. \Glspl{candidate} are now generated at the very last index of the search \gls{query} whether or not they are followed by a `\$' symbol in the \gls{text}. These special candidates would represent an occurrence of a \gls{derivation} of the \textit{entire} query string somewhere in the text (not only as the suffix to some $S$ string). The \glspl{match location} for generated candidates likely do not align with `\$' positions in the text; Thus determining to which $S$ string the match location belongs presents a minor computational challenge. Many approaches are possible, but we suggest a binary search over the known `\$' indices in the text, matching the largest `\$' index that is smaller or equal to the found index; Knowledge of which `\$' string to associate with the match location provides enough information to determine which $S$ string is associated with the found overlap, and consequently, affords the generation of a candidate;
 
Under most circumstances, allowing for inclusions greatly increases the number of candidates generated and thus increases the time taken to complete the \gls{verification step}. To see this in action, refer to Section \ref{extension_runtimes}.