\chapter{Future Work}
With such a complex system and such large data sets, very many experiments can be concocted that would each be more interesting than the last. Additionally, there is a lot of potential for improvement of our solver through improvement of the implementation itself. Unfortunately, due to a shortage of time, exploration of all of these avenues was not possible. As such, this section highlights a number of potential focal points that seem likely to result in fruitful future works.

\section{Future Implementation}

Initially, it was intended for a greater proportion of time to be spent experimenting with the effects of using different (and perhaps novel) \glspl{partitioning scheme}. Even comparison against provably-worse schemes than that of Kucherov's algorithm would give a lot of information about the nature of the relationship between the \gls{pattern} partition and runtime.


Our \aspop{} solver implementation is not capable of efficiently dealing with \glspl{indel} at the moment, and there is unlikely to be a cheap `silver bullet' solution that will change that any time soon. In this facet, competitors such as \textsc{blast} are likely to keep their advantage for the time being. At least in the face of short-\gls{read} sequence data, so far the use of indels does not appear to help find more `real' overlaps from the same source genome very often, and in fact consideration of indels can do more harm than good \textit{aside} from the increased runtime. Read data usually contains indels so rarely (circa 10 times rarer than \glspl{substitution} \cite{err_rates}), that the bulk of indel-containing \glspl{solution} mostly just inflate \textit{false positive} rates, causing detriment to later steps of the assembly process. This realization came late in the progress of this project, with a great deal of time already having been spent trying to make indel mode efficient (to little avail). At least in its current state, indel mode is functional in the event of small data sets or many cores.


More drastic changes in approach might be necessary to dramatically increase the speed of Kucherov's algorithm further. However, due to its complicated nature, there are a number of interesting projects that could be borne of this one. For example, in-depth knowledge of systems programming would allow someone with the right skill-set to squeeze more speedup out of the same algorithm. Another viable approach might be a more \textit{specialized} implementation, stripping away the modularity required to support optional running modes and the swappable \textit{mode} component described in Section~\ref{structure}. A leaner, purpose-built implementation might not only be faster on paper, but would also be able to skip some minor internal trans-representation conversion steps, exposing some opportunities for clever tricks that would push efficiency to the next level.

Development of a viable auxiliary \textit{correctness-checker} was considered for this project, but it was ultimately scrapped due to time constraints. This program would have allowed automated testing of the correctness of the \gls{suffix filter} algorithm's \textit{mode} module. This would allow the user to tinker with the code for \glspl{filter} and \gls{pattern} partitioning, with the  correctness-checker ensuring that the algorithm remains exact. This would allow for the kind of rapid iteration that might lead to a new breakthrough for the \gls{filter algorithm}, much in the way \kark{} created suffix filters from the existing \glspl{substring filter}. 

\section{Future Experimentation}

There was not enough time to test the effects of using optional \glspl{inclusion} on the output quality, much as it was done in Section~\ref{phase1}. It would also be interesting to understand their usefulness for the sequence assembly process. Information about these ramifications would help to clarify in which cases the user should enable inclusions. The same could be said with respect to \glspl{reversal}; Although the resulting doubling of the number of searched \glspl{read} is clear, it is not apparent to which extent these reversed reads reduce the pruning of nodes in \gls{query} search trees, as was tested \textit{without} considering reversals in Section~\ref{aux:nodes}.

It would be interesting to explore the behavior of all three solvers in the face of large data sets of different \textit{kinds} of data to identify the niches in which each solver shines.

In the spirit of the experiments of phase~1 (Section~\ref{phase2}), a more exhaustive exploration of which parameters to select for different applications would also be quite illuminating; This could help to specialize the advisable parameter settings for different possible use cases.
