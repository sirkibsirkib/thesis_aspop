\section{Context}
\label{context}

An \aspop{} solver has a number of applications in the field of Bioinformatics. Arguably, the most common application is as part of a genome assembly pipeline designed to iteratively agglutinate overlapping reads into chains until the full genome is acquired.

Our work is primarily interested in developing an \aspop{} solver as part of the assembly of viral DNA. Viral DNA has a number of properties not ubiquitous to DNA in general, such as more modestly-sized genomes. Often the solver is intended to distinguish between numerous \gls{source genome} \textit{strains} mixed into the data set. Such strains have much in common for viral DNA; As such, they have very many runs of identical nucleotides. To tell one strain from another, it makes sense to ignore extremely short overlaps, as a significant proportion of short overlaps are expected between different strains. To reduce the discovery of these deceiving solutions, valid overlaps  only with with lengths above 80-100 nucleotides are retained, considered `likely enough' to be from overlaps within the same strain. For the purpose of this work, whenever necessary, this value is pinned down to 80. To compensate for the diminished solution set resulting from discarding overlaps, generally data sets for viral DNA contain a significant number of \glspl{genome copy} (Data sets with a high degree of \gls{coverage}), generally in the range of 10 000x to 100 0000x. At the moment, such an assembly problem simply involves too many reads for our existing \aspop{} solvers to deal with at a time, leading to runaway time and space requirements. A viable workaround involves partitioning the original data set into a \textit{set} of smaller problems the \aspop{} solver can manage, then combining results later down the assembly pipeline. It is our hope that a more efficient \aspop{} solver can reduce the granularity of this partitioning, or better yet, avoid it entirely.
